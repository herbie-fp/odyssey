import React, { useState, useEffect, ChangeEvent } from 'react';
// import _ from 'lodash'; // We will use lodash's debounce function
//const debounce = (callback, delay) => {
//  return _.debounce(callback, delay);
//}
import * as math11 from 'mathjs';
import * as fpcorejs from './fpcore.js';
// import katex library
import katex from 'katex';

type VarValues = { [key: string]: { low: string | undefined, high: string | undefined} };

function debounce( callback: any, delay:any ) {
  let timeout :any;
  return function(...args :any) {
      clearTimeout( timeout );
      timeout = setTimeout(() => callback(...args), delay );
  }
}
const zip = (arr1: any[], arr2: any[], arr3=[]) => arr1.reduce((acc, _, i) => (acc.push([arr1[i], arr2[i], arr3?.[i]]), acc), [])


function cleanupTex(node :any, options :any) {
  if (node.fn?.name === 'hypot' && !(node.args.length === 2)) { throw Error('hypot takes two arguments') }
  if (node.fn?.name === 'log1p' && !(node.args.length === 1)) { throw Error('log1p takes one argument') }
  if (node.fn?.name === 'log' && !(node.args.length === 1)) { throw Error('log takes one argument') }
  return node.fn?.name === 'hypot' ? `\\mathbf{hypot}(${node.args[0].toTex(options)}, ${node.args[1].toTex(options)})` 
    : node.fn?.name === 'log1p' ? `\\mathbf{log1p}(${node.args[0].toTex(options)})`
    : node.fn?.name === 'log' ? `\\mathbf{log}(${node.args[0].toTex(options)})`
    : node._toTex(options)
}
function branchConditionalHandler(node :any, options: any) {
  options = {handler: cleanupTex}
  if (node.type !== 'ConditionalNode') {
    return node.toTex(options)
  }
  const deparen = (node:any) => node.type === 'ParenthesisNode' ? node.content : node
  const conditions = [node]
  let curr = node
  while (deparen(curr.falseExpr).type === 'ConditionalNode') {
    conditions.push(deparen(curr.falseExpr))
    curr = deparen(curr.falseExpr)
  }
  conditions.push(conditions[conditions.length - 1])  // duplicate the final condition
  
  const deparenCondition = (c :any) => ({...c, condition: deparen(c.condition), trueExpr: deparen(c.trueExpr), falseExpr: deparen(c.falseExpr)})
  return conditions.map(deparenCondition).map((c, i) => 
    i === 0 ? `\\mathbf{if} \\> ${c.condition.toTex(options)}: \\\\ \\quad ${c.trueExpr.toTex(options)}`
    : i !== conditions.length - 1 ? `\\mathbf{elif} \\> ${c.condition.toTex(options)}: \\\\ \\quad ${c.trueExpr.toTex(options)}`
    : `\\mathbf{else :} \\\\ \\quad ${c.falseExpr.toTex(options)}`).join('\\\\')
}
const math2Tex = (mathjs : any) => {
  return math11.parse(mathjs.replaceAll('!', 'not').replaceAll('||', 'or').replaceAll('&&', 'and')).toTex({handler: branchConditionalHandler})
}

interface VariableInputProps {
  variableName: string;
  variableValue: { low: string, high: string };
  handleValueChange: (e: ChangeEvent<HTMLInputElement>) => void;
}

const VariableInput: React.FC<VariableInputProps> = ({ variableName, variableValue, handleValueChange }) => (
  <tr className="spec-var-row">
    <td className="varname">{variableName}:</td> 
    <td>
      <input 
        type="text" 
        className={`var-low var-${variableName}`} 
        value={variableValue.low}
        onChange={handleValueChange}
      />
    </td>
    <td>to</td>
    <td>
      <input 
        type="text" 
        className={`var-high var-${variableName}`} 
        value={variableValue.high}
        onChange={handleValueChange}
      />
    </td>
  </tr>
)

interface ErrorMessageProps {
  message: string;
}

const ErrorMessage: React.FC<ErrorMessageProps> = ({ message }) => <div>{message}</div>

const NewSpecInput: React.FC = () => {
  const [text, setText] = useState<string>('sqrt(x + 1) - sqrt(x)');
  const [varValues, setVarValues] = useState<VarValues>({ x: { low: "0", high: "1e308" } });

  const handleErrors = (tryBody: any, catchBody = (e: any) => e) => {
    try { return tryBody() } catch (e) { return catchBody(e) }
  }

  // This part assumes fpcorejs.getVarnamesMathJS, math2Tex, and addSpec are imported.
  // const varnames = handleErrors(() => fpcorejs.getVarnamesMathJS(text.split('\n').join('')).map((v: string) => (setVarValues((old: VarValues) => ({ [v]: { low: '-1.79e308', high: '1.79e308', ...old[v] } })), v)), (e: any) => (console.error(e), []));
  const varnames = fpcorejs.getVarnamesMathJS(text.split('\n').join(''))

  const rangeErrors = (all = false) => {
    const errors = varnames.map((v: string) => fpcorejs.rangeErrors([varValues[v].low, varValues[v].high], !all && varValues[v].low === '' && varValues[v].high === '')).flat();
    return zip(errors, varnames).map(([e, v]: any[]) => `${v}: ${e}`);
  }

  useEffect(() => {
    window.setVarValues = setVarValues;
  }, []);

  const handleValueChange = (e: ChangeEvent<HTMLInputElement>) => {
    const variableName = e.target.className.split(' ')[1].split('-')[1];
    const variableRange = e.target.className.split(' ')[0].split('-')[1];
    setVarValues({ ...varValues, [variableName]: { ...varValues[variableName], [variableRange]: e.target.value } });
  }

  return (
    <div>
      <h3>
        The expression you would like to approximate:
      </h3>
      <textarea 
        value={text}
        onChange={debounce((e: ChangeEvent<HTMLTextAreaElement>) => setText(e.target.value), 500)}
        className='newSpecInput'
      />

      <div id="texPreview">
        {/* Assuming math2Tex and katex.renderToString functions exist */}
        {text !== '' && <span className="preview-stuff" dangerouslySetInnerHTML={{__html: katex.renderToString(math2Tex(text.split('\n').join('')), {
            throwOnError: false
          })}} />}
      </div>
      
      <h3>
        The input ranges you would like to focus on improving:
      </h3>

      <table>
        {varnames.map((v) => 
          <VariableInput 
            key={v}
            variableName={v}
            variableValue={varValues[v]}
            handleValueChange={handleValueChange}
          />
        )}
      </table>

      {rangeErrors(false).map((e: any, i: number) => <ErrorMessage key={i} message={e} />)}

      {varnames.length > 0 && rangeErrors(true).length === 0 && 
        <button onClick={() => addSpec({ mathjs: text.split('\n').join(''), fpcore: undefined, ranges: varnames.map(v => [v, [varValues[v].low, varValues[v].high]]) })}>
          Submit
        </button>
      }
    </div>
  );
}

export default NewSpecInput;
