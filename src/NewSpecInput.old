import React, { useState, useEffect } from 'react';
// import _ from 'lodash'; // We will use lodash's debounce function
const fpcorejs = require('./fpcore.js');

// import the mathjs library
import * as math11 from 'mathjs';

//const debounce = (callback, delay) => {
//  return _.debounce(callback, delay);
//}
function debounce( callback: any, delay:any ) {
  let timeout :any;
  return function(...args :any) {
      clearTimeout( timeout );
      timeout = setTimeout(() => callback(...args), delay );
  }
}

const math2Tex = (mathjs : any) => {
  return math11.parse(mathjs.replaceAll('!', 'not').replaceAll('||', 'or').replaceAll('&&', 'and')).toTex({handler: branchConditionalHandler})
}

const NewSpecInput = () => {
  // TODO: this is ugly old code with no typescript types
  const [text, setText] = useState('sqrt(x + 1) - sqrt(x)');
  const [varValues, setVarValues] = useState({ x: { low: 0, high: 1e308 } } as any);

  // Handle errors
  const handleErrors = (tryBody: any, catchBody=e => e) => {
    try { return tryBody() } catch (e) { return catchBody(e) }
  }

  const varnames = handleErrors(() => fpcorejs.getVarnamesMathJS(text.split('\n').join('')).map((v: any) => (setVarValues({ low: -1.79e308, high: 1.79e308, ...v })), e => (console.error(e), [])));

  const zip = (arr1: any[], arr2: any[], arr3=[]) => arr1.reduce((acc, _, i) => (acc.push([arr1[i], arr2[i], arr3?.[i]]), acc), [])

  const rangeErrors = (all = false) => {
    const errors = varnames.map((v: any) => fpcorejs.rangeErrors([varValues[v].low, varValues[v].high], !all && varValues[v].low === '' && varValues[v].high === '')).flat();
    return zip(errors, varnames).map(([e, v] : any) => `${v}: ${e}`);
  }

  useEffect(() => {
    //@ts-ignore
    window.setVarValues = setVarValues; // ugly HACK for letting new page force these values to change
  }, []);

  return (
    <div>
      <h3>
        The expression you would like to approximate:
      </h3>
      <textarea 
        value={text}
        onChange={debounce((e) => setText(e.target.value), 500)}
        className='newSpecInput'
      />

      <div id="texPreview">
        {/* Assuming math2Tex and katex.renderToString functions exist */}
        //@ts-ignore
        {text !== '' && <span className="preview-stuff" dangerouslySetInnerHTML={{__html: (window as any).katex.renderToString(math2Tex(text.split('\n').join('')), {
            throwOnError: false
          })}} />}
      </div>
      
      <h3>
        The input ranges you would like to focus on improving:
      </h3>

      <table>
      {varnames.map(v => (
        <tr key={v} className="spec-var-row">
          <td className="varname">{v}:</td> 
          <td>
            <input 
              type="text" 
              className={`var-low var-${v}`} 
              value={varValues[v].low}
              onChange={debounce((e) => setVarValues({ ...varValues, [v]: { ...varValues[v], low: e.target.value } }), 400)}
            />
          </td>
          <td>to</td>
          <td>
            <input 
              type="text" 
              className={`var-high var-${v}`} 
              value={varValues[v].high}
              onChange={debounce((e) => setVarValues({ ...varValues, [v]: { ...varValues[v], high: e.target.value } }), 400)}
            />
          </td>
        </tr>
      ))}
      </table>

      {rangeErrors(false).map((e, i) => <div key={i}>{e}</div>)}

      {varnames.length > 0 && rangeErrors(true).length === 0 && 
        <button onClick={() => addSpec({ mathjs: text.split('\n').join(''), fpcore: undefined, ranges: varnames.map(v => [v, [varValues[v].low, varValues[v].high]]) })}>
          Submit
        </button>
      }
    </div>
  );
}

export default NewSpecInput;